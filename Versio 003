// INCLUDET
#define DisplaySerial Serial // Using Hardware Serial
#include "Picaso_Serial_4DLib\Picaso_Const4D.h"
#include "Picaso_Serial_4DLib\Picaso_Serial_4DLib.h"
#include <math.h>
Picaso_Serial_4DLib Display(&DisplaySerial);

// ALKUMÄÄRITYKSET
char * paiva;
/// Valikkojen määritykset
int menu = 1;
int select = 1;
/// Ajan muuttujat
int timer1_counter;
int day;
int hour = 0;
int minute = 0;
long second = 0;
/// Hälytyksen muuttujat
int alarm_hour = 0;
int alarm_minute = 0;
/// Muita muuttujia
int canpress = 1;
int update_inverval = 0;
long cnt = 0;
long lastCnt = 0;
bool draw = true;
/// Piirtämiseen liittyviä
int colourvalue; // HEXANA
char tempstring[256] = { 0 }; // Temporary String Variable for putstr
bool redraw_menu = true;


// TULOSTAMINEN &
// PIIRTOFUNKTIOT

/// Päivän tulostus
void draw_Day(int days) {
	Display.txt_Height(2);
	Display.txt_Width(2);
	Display.txt_FGcolour(colourvalue);
	Display.gfx_MoveTo(31, 27);

	if (days == 0)
		paiva = "    Maanantai   ";
	if (days == 1)
		paiva = "     Tiistai    ";
	if (days == 2)
		paiva = "   Keskiviikko  ";
	if (days == 3)
		paiva = "     Torstai    ";
	if (days == 4)
		paiva = "    Perjantai   ";
	if (days == 5)
		paiva = "    Lauantai    ";
	if (days == 6)
		paiva = "    Sunnuntai   ";

	sprintf(tempstring, paiva, colourvalue);
	Display.putstr(tempstring);
}

/// Valikon piirto
void draw_Menu() {
	colourvalue = 0xFFE0;

	/// Painikkeiden reunat
	Display.gfx_Rectangle(1, 1, 62, 24, colourvalue);
	Display.gfx_Rectangle(65, 1, 126, 24, colourvalue);
	Display.gfx_Rectangle(129, 1, 190, 24, colourvalue);
	Display.gfx_Rectangle(193, 1, 254, 24, colourvalue);
	Display.gfx_Rectangle(257, 1, 318, 24, colourvalue);

	/// Fontin väri
	Display.txt_FGcolour(colourvalue);

	Display.txt_Width(1);
	Display.txt_Height(1);

	Display.gfx_MoveTo(16, 7);
	sprintf(tempstring, "MAIN", colourvalue);
	Display.putstr(tempstring);
	Display.gfx_MoveTo(76, 7);
	sprintf(tempstring, "ALARM", colourvalue);
	Display.putstr(tempstring);
	Display.gfx_MoveTo(144, 7);
	sprintf(tempstring, "TIME", colourvalue);
	Display.putstr(tempstring);
	Display.gfx_MoveTo(212, 7);
	sprintf(tempstring, "LED", colourvalue);
	Display.putstr(tempstring);
	Display.gfx_MoveTo(269, 7);
	sprintf(tempstring, "AUDIO", colourvalue);
	Display.putstr(tempstring);
}

/// Kellonajan piirto
void draw_Time(int hr, int mi, int se) {
	Display.txt_Height(3);
	Display.txt_Width(3);
	Display.txt_FGcolour(colourvalue);
	Display.gfx_MoveTo(66, 50);
	sprintf(tempstring, "%002d:%002d:%002d", hr, mi, se, colourvalue);

	Display.putstr(tempstring);
}

///Analogisen kellon pohjan piirtäminen
/// FOR LOOPPI KELLON "TICKEILLE"
void draw_AnalogBack() {

	Display.gfx_Circle(162, 160, 70, colourvalue);
	Display.gfx_Circle(162, 160, 71, colourvalue);
	Display.gfx_Circle(162, 160, 72, colourvalue);

	/// "Tickkien välit"
	int lengthTick = 10;
	int medTick = 30;
	int longTick = 50;
	int r = 70;

	for (int i = 0; i <= 60; i++) {

		int len = 5;

		if (i % 5 == 0) { len = 10; }
		if (i % 15 == 0) { len = 15; }

		double di = (double)i;

		double angleFrom12 = di / 60*2* M_PI;
		double angleFrom3 = M_PI / 2 - angleFrom12;

		/// Ympyrän keskipiste
		int cX = 162;
		int cY = 160;

		/// X1,Y1 koordinaatit
		float tick_x1 = (cX + cos(angleFrom3)*r);
		float tick_y1 = (cY + sin(angleFrom3)*r);
		/// X2,Y2 Koordinaatit
		float tick_x2 = (cX + cos(angleFrom3)*(r - len));
		float tick_y2 = (cY + sin(angleFrom3)*(r - len));

		Display.gfx_Line(tick_x1, tick_y1, tick_x2, tick_y2, colourvalue);
	}
}
/// Analogisen kellon piirtäminen
void draw_Analog(int se) {

	/*for (int i = 1; i <= 60; i++) {
		// default tick length is short
		int len = lengthTick;
		if (i % 15 == 0) {
			// Longest tick on quarters (every 15 ticks)
			len = longTick;
		}
		else if (i % 5 == 0) {
			// Medium ticks on the '5's (every 5 ticks)
			len = medTick;
		}*/
	/// Tuntiviisari
		/*
		int len = 60;
		double di = (double)se;
		double secondAngle = se / 60 * 2 * M_PI;
		int cX = 162;
		int cY = 160;

		/// X1,Y1 koordinaatit
		float tick_x1 = cX;
		float tick_y1 = cY;
		/// X2,Y2 Koordinaatit
		float tick_x2 = (cX + cos(secondAngle)*(r - len));
		float tick_y2 = (cY + sin(secondAngle)*(r - len));

		Display.gfx_Line(tick_x1, tick_y1, tick_x2, tick_y2, colourvalue);
		*/
		

	/// Minuuttiviisari

	/// Sekunttiviisari
}

// AJAN TOIMINTA
// AJAN MUUTTAMISET YMS

void countTime() {

	if (minute == 60) {
		hour = hour + 1;
		minute = 0;
	}

	if (hour == 0) {
	}

}

/// Päivän hakeminen
int getDay(long sec) {
	int days;
	days = sec / 86400;

	return days;
}
/// Tunnin hakeminen
long getHour(long sec) {
	long mod;
	long hour;
	mod = sec % 86400;

	hour = mod / 3600;

	return hour;
}
/// Minuuttien hakeminen
long getMin(long sec) {
	long mod;
	long hour;
	long minu;

	mod = sec % 86400;

	hour = mod % 3600;
	minu = hour / 60;
	return minu;
}
/// Sekunttien hakeminen
long getSec(long sec) {
	return sec % 60;
}

/// Päivän kasvattaminen
void day_increment() {
	long buff;
	buff = second;
	if (buff>86400) buff = buff % 86400;
	noInterrupts();
	if (second>518399)
		second = buff;
	else second = second + 86400;
	//delay(300);
	interrupts();
}
/// Tuntien kasvattaminen
void hour_increment() {
	long buff;
	buff = second;
	if (buff>86400) buff = buff % 86400;
	noInterrupts();
	if (second>518399)
		second = buff;
	else second = second + 3600;
	//delay(300);
	interrupts();
}
/// Minuuttien kasvattaminen
void minute_increment() {
	long buff;
	buff = second;
	if (buff>86400) buff = buff % 86400;
	noInterrupts();
	if (second>518399)
		second = buff;
	else second = second + 60;

	second = second / 60;
	second = second * 60;

	//delay(300);
	interrupts();
}

/// Päivän vähentäminen
void day_decrement() {
	if (second >= 86400) {
		long buff;
		buff = second;
		if (buff > 86400) buff = buff % 86400;
		noInterrupts();
		if (second > 518399)
			second = buff;
		else second = second - 86400;
		//delay(300);
		interrupts();
	}
}
/// Tuntien vähentäminen
void hour_decrement() {
	if (second >= 3600) {
		long buff;
		buff = second;
		if (buff > 86400) buff = buff % 86400;
		noInterrupts();
		if (second > 518399)
			second = buff;
		else second = second - 3600;
		//delay(300);
		interrupts();
	}
}
/// Minuuttien vähentäminen
void minute_decrement() {
	if (second >= 60) {
		long buff;
		buff = second;
		if (buff > 86400) buff = buff % 86400;
		noInterrupts();
		if (second > 518399)
			second = buff;
		else second = second - 60;

		second = second / 60;
		second = second * 60;

		//delay(300);
		interrupts();
	}
}

// SETUP
void setup() {
	///Ajastimen määritykset
	noInterrupts();           // disable all interrupts
	TCCR1A = 0;
	TCCR1B = 0;

	timer1_counter = 3036;
	TCNT1 = timer1_counter;   // preload timer
	TCCR1B |= (1 << CS12);    // 256 prescaler 
	TIMSK1 |= (1 << TOIE1);   // enable timer overflow interrupt
	interrupts();             // enable all interrupts

							  /// Näytön määritykset
	pinMode(4, OUTPUT);  // Set D4 on Arduino to Output (4D Arduino Adaptor V2 - Display Reset)
	digitalWrite(4, 1);  // Reset the Display via D4
	delay(100);
	digitalWrite(4, 0);  // unReset the Display via D4  
	delay(3500); //let the display start up

	DisplaySerial.begin(9600); // Using default 9600 baud rate
	Display.TimeLimit4D = 5000; // 5 second timeout on all commands  
	Display.gfx_BGcolour(BLACK); // Make it text on white background
	Display.txt_BGcolour(BLACK);
	Display.gfx_ScreenMode(4); // Landscape, microSD Card Facing Up  
	Display.gfx_Cls(); // Clear Screen
}

// AJASTIN
/// interrupt service routine 
ISR(TIMER1_OVF_vect)
{
	TCNT1 = timer1_counter;   // preload timer
	second = second + 1;
	draw = true;
}

/// *********************** ///
//		  PÄÄLOOPPI         //
/// ********************** ///
void loop() {

	/// Jos sekunnit menevät yli 604799 (=Yksi viikko) niin nollataan ne

	// PÄÄ PIIRTOLOOP
	if (draw == true) {
		draw_Time(getHour(second), getMin(second), getSec(second));
		draw_Day(getDay(second));
		draw = false;
	}

	if (redraw_menu == true) {
		draw_Menu();
		draw_AnalogBack();
		redraw_menu = false;
	}

	if (second > 604799) { second = 0; }
	cnt = cnt + 1;

	//Kutsutaan päivän ja kelloajan tulostusfunktioita

}
